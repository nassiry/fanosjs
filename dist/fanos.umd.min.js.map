{"version":3,"file":"fanos.umd.min.js","sources":["../src/config.js","../src/utils.js","../src/randomUUID.js","../src/requestHandler.js","../src/fanos.js"],"sourcesContent":["export const config = Object.freeze({\n  url: null,\n  headers: { 'Content-Type': 'application/json' },\n  storeKey: '__FANOS__',\n  autoFlush: true,\n  storeFailed: true,\n  debug: false,\n  retryInterval: 5000,\n  maxPayloadSize: 64000,\n  maxAttemptsPerRequest: 3,\n  maxRetryCycles: 10,\n  maxRetryDelay: 300000,\n  fallbackToFetch: false,\n})\n","export const normalizePayload = (data, headers) => {\n  if (\n    data instanceof Blob ||\n    data instanceof FormData ||\n    data instanceof URLSearchParams\n  ) {\n    return data\n  }\n  return new Blob([JSON.stringify(data)], { type: headers['Content-Type'] })\n}\n\nexport const createPayload = (data, headers) => normalizePayload(data, headers)\n\nexport const getPayloadSize = (payload) => {\n  if (payload instanceof Blob) return payload.size\n  if (payload instanceof FormData) {\n    return [...payload.entries()].reduce(\n      (size, [key, value]) =>\n        size + key.length + (typeof value === 'string' ? value.length : 0),\n      0,\n    )\n  }\n  if (payload instanceof URLSearchParams) {\n    return new TextEncoder().encode(payload.toString()).length\n  }\n  return new TextEncoder().encode(JSON.stringify(payload)).length\n}\n\nexport function debounce(fn, delay) {\n  let timeout\n  return (...args) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => fn.apply(this, args), delay)\n  }\n}\n\nexport const debugLog = (debug, ...args) => {\n  if (debug === true || debug === 'info') {\n    console.debug('[Fanos]', ...args)\n  }\n}\n","import { debugLog } from './utils.js'\n\nexport const randomUUID = (debug) => {\n  try {\n    if (crypto && crypto.randomUUID) {\n      return crypto.randomUUID()\n    }\n  } catch (e) {\n    debugLog(\n      debug,\n      'crypto.randomUUID() failed, falling back to alternative method',\n      e,\n    )\n  }\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0,\n      v = c === 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n","import {\n  createPayload,\n  debugLog,\n  getPayloadSize,\n  normalizePayload,\n} from './utils.js'\n\nimport { randomUUID } from './randomUUID.js'\n\nexport class RequestHandler {\n  constructor(config, queue) {\n    this._config = config\n    this._queue = queue\n  }\n\n  sendRequest(request) {\n    const payload = createPayload(request.data, request.headers)\n    const payloadSize = getPayloadSize(payload)\n\n    if (payloadSize > this._config.maxPayloadSize) {\n      debugLog(this._config.debug, 'Warning: Payload too large, splitting...')\n      return this.splitAndSend(request)\n    }\n\n    const success = navigator.sendBeacon(request.url, payload)\n    if (success) {\n      debugLog(this._config.debug, 'Beacon succeeded:', request.id)\n      this._queue.delete(request)\n      return true\n    }\n\n    if (this._config.fallbackToFetch) {\n      return this.fetchFallback(request)\n    }\n\n    return false\n  }\n  createRequest(data, options) {\n    return {\n      id: randomUUID(this._config.debug),\n      url: options.url || this._config.url,\n      headers: { ...this._config.headers, ...options.headers },\n      data,\n      attempts: 0,\n      timestamp: Date.now(),\n    }\n  }\n\n  async splitAndSend(request) {\n    debugLog(this._config.debug, `Splitting large request: ${request.id}`)\n\n    const payload = normalizePayload(request.data, request.headers)\n    const payloadStr =\n      payload instanceof Blob\n        ? await payload.text()\n        : JSON.stringify(request.data)\n    const chunkSize = this._config.maxPayloadSize - 1000\n    const chunks = []\n\n    for (let i = 0; i < payloadStr.length; i += chunkSize) {\n      chunks.push(payloadStr.slice(i, i + chunkSize))\n    }\n\n    let allSent = true\n    chunks.forEach((chunk, index) => {\n      const chunkBlob = new Blob([chunk], {\n        type: request.headers['Content-Type'],\n      })\n      const success = navigator.sendBeacon(request.url, chunkBlob)\n      if (!success) {\n        debugLog(this._config.debug, `Chunk ${index + 1} failed to send`)\n        allSent = false\n      }\n    })\n\n    if (allSent) {\n      this._queue.delete(request)\n    }\n\n    return allSent\n  }\n\n  async fetchFallback(request) {\n    try {\n      const response = await fetch(request.url, {\n        method: 'POST',\n        headers: request.headers,\n        body: createPayload(request.data, request.headers),\n        keepalive: true,\n      })\n\n      if (!response.ok) {\n        const errorText = await response.text()\n        throw new Error(`HTTP ${response.status}: ${errorText}`)\n      }\n\n      debugLog(this._config.debug, 'Fetch fallback succeeded:', request.id)\n      this._queue.delete(request)\n      return true\n    } catch (error) {\n      debugLog(this._config.debug, 'Fetch fallback failed:', error)\n      return false\n    }\n  }\n}\n","// Fanos.js\nimport { config } from './config.js'\n\nimport { debounce, debugLog } from './utils.js'\nimport { RequestHandler } from './requestHandler.js'\n\nexport class Fanos {\n  static defaults = config\n  static instance = new Fanos()\n\n  constructor(options = {}) {\n    this.config = { ...Fanos.defaults, ...options }\n    this.queue = new Set()\n    this.abortController = new AbortController()\n    this.requestHandler = new RequestHandler(this.config, this.queue)\n    this.retryTimer = null\n    this._initialized = false\n  }\n\n  static send(data, options) {\n    return Fanos.instance.send(data, options)\n  }\n\n  static configure(options) {\n    Object.assign(Fanos.instance.config, options)\n    return Fanos.instance\n  }\n\n  static flush() {\n    Fanos.instance?.flush()\n  }\n\n  static destroy() {\n    Fanos.instance?.destroy()\n  }\n\n  send(data, options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!this._initialized) this._initialize()\n\n      const request = this.requestHandler.createRequest(data, options)\n      debugLog(this.config.debug, 'Sending request:', { request })\n\n      try {\n        const success = this.requestHandler.sendRequest(request)\n        success ? resolve() : this._handleFailure(request, reject)\n      } catch (error) {\n        this._handleFailure(request, reject, error)\n      }\n    })\n  }\n\n  flush() {\n    if (this.queue.size === 0) {\n      debugLog(this.config.debug, 'Queue is empty, skipping flush.')\n      return\n    }\n\n    debugLog(this.config.debug, `Flushing queue with ${this.queue.size} items`)\n    const successfulRequests = new Set()\n    const maxRetry = this.config.maxAttemptsPerRequest\n\n    for (const request of this.queue) {\n      if (request.attempts >= maxRetry) continue\n      try {\n        if (this.requestHandler.sendRequest(request))\n          successfulRequests.add(request.id)\n      } catch (error) {\n        debugLog(this.config.debug, 'Flush error:', error)\n      }\n    }\n\n    this.queue.forEach((request) => {\n      if (successfulRequests.has(request.id) || request.attempts >= maxRetry) {\n        this.queue.delete(request)\n      }\n    })\n\n    if (this.queue.size > 0) {\n      this._persistQueue()\n    } else if (this.config.debug) {\n      debugLog(this.config.debug, 'Queue is empty, skipping persistence.')\n    }\n  }\n\n  destroy() {\n    debugLog(this.config.debug, 'Destroying instance')\n    this.abortController.abort()\n    clearTimeout(this.retryTimer)\n    this.queue.clear()\n    this._persistQueue()\n    this._initialized = false\n  }\n\n  _initialize() {\n    debugLog(this.config.debug, 'Initializing...')\n    this._loadQueue()\n    this._eventHandler()\n    this._scheduleRetries()\n    this._initialized = true\n  }\n\n  _handleFailure(request, reject, error = new Error('Beacon failed')) {\n    request.attempts++\n    debugLog(\n      this.config.debug,\n      `Request ${request.id} failed (attempt ${request.attempts})`,\n    )\n\n    if (this.config.storeFailed) {\n      this.queue.add(request)\n      this._persistQueue()\n    }\n\n    reject(error)\n  }\n\n  _scheduleRetries(attempt = 1) {\n    if (this.retryTimer) clearTimeout(this.retryTimer)\n\n    if (this.queue.size === 0) {\n      debugLog(this.config.debug, 'Queue is empty, stopping retries.')\n      return\n    }\n\n    const maxRetryCycles = this.config.maxRetryCycles || 10\n    if (attempt > maxRetryCycles) {\n      debugLog(\n        this.config.debug,\n        'Max retry attempts reached, stopping retries.',\n      )\n      return\n    }\n\n    const maxDelay = this.config.maxRetryDelay || 300000\n    const delay = Math.min(\n      this.config.retryInterval * 2 ** (attempt - 1),\n      maxDelay,\n    )\n\n    this.retryTimer = setTimeout(() => {\n      this.flush()\n      this._scheduleRetries(attempt + 1)\n    }, delay)\n  }\n\n  _eventHandler() {\n    if (!this.config.autoFlush) return\n\n    this.abortController.abort()\n    this.abortController = new AbortController()\n\n    const handler = () => {\n      if (this.queue.size > 0) {\n        debugLog(this.config.debug, 'Auto-flushing queue due to unload event.')\n        this.flush()\n      } else if (this.config.debug) {\n        debugLog(this.config.debug, 'Queue is empty, skipping auto-flush.')\n      }\n    }\n\n    const { signal } = this.abortController\n\n    ;['pagehide', 'beforeunload', 'visibilitychange'].forEach((event) => {\n      window.addEventListener(event, handler, { signal })\n    })\n  }\n\n  _loadQueue() {\n    try {\n      const stored = localStorage.getItem(this.config.storeKey)\n      if (stored) {\n        const parsed = JSON.parse(stored)\n        if (Array.isArray(parsed)) {\n          this.queue = new Set(parsed)\n          debugLog(\n            this.config.debug,\n            `Loaded queue from storage: ${parsed.length} items`,\n          )\n        }\n      }\n    } catch (error) {\n      debugLog(this.config.debug, 'Error loading queue:', error)\n      this.queue.clear()\n    }\n  }\n\n  _persistQueue = debounce(() => {\n    if (!this.config.storeFailed || this.queue.size === 0) {\n      if (this.config.debug) {\n        debugLog(\n          this.config.debug,\n          'Skipping persistence: queue is empty or storeFailed is false.',\n        )\n      }\n      return\n    }\n\n    try {\n      const serialized = JSON.stringify(\n        [...Array.from(this.queue)].slice(0, 100),\n      )\n      localStorage.setItem(this.config.storeKey, serialized)\n      debugLog(this.config.debug, `Persisted queue: ${this.queue.size} items`)\n    } catch (error) {\n      debugLog(this.config.debug, 'Persist error:', error)\n    }\n  }, 500)\n}\n"],"names":["config","Object","freeze","url","headers","storeKey","autoFlush","storeFailed","debug","retryInterval","maxPayloadSize","maxAttemptsPerRequest","maxRetryCycles","maxRetryDelay","fallbackToFetch","normalizePayload","data","Blob","FormData","URLSearchParams","JSON","stringify","type","createPayload","debugLog","args","console","randomUUID","crypto","e","replace","c","r","Math","random","toString","RequestHandler","constructor","queue","this","_config","_queue","sendRequest","request","payload","payloadSize","size","entries","reduce","key","value","length","TextEncoder","encode","getPayloadSize","splitAndSend","navigator","sendBeacon","id","delete","fetchFallback","createRequest","options","attempts","timestamp","Date","now","payloadStr","text","chunkSize","chunks","i","push","slice","allSent","forEach","chunk","index","chunkBlob","response","fetch","method","body","keepalive","ok","errorText","Error","status","error","Fanos","static","defaults","Set","abortController","AbortController","requestHandler","retryTimer","_initialized","send","instance","configure","assign","flush","destroy","Promise","resolve","reject","_initialize","_handleFailure","successfulRequests","maxRetry","add","has","_persistQueue","abort","clearTimeout","clear","_loadQueue","_eventHandler","_scheduleRetries","attempt","maxDelay","delay","min","setTimeout","handler","signal","event","window","addEventListener","stored","localStorage","getItem","parsed","parse","Array","isArray","fn","timeout","apply","debounce","serialized","from","setItem"],"mappings":"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"}